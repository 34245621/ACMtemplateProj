# 6. 数学

## 6.1. 质数与约数

## 6.1.1 筛法

### 6.1.1.1 欧拉筛

> 欧拉筛法求2到n的所有质数。
> 欧拉筛法的时间复杂度为$O$($n$)，空间复杂度为$O$($n$)。
> 欧拉筛与拓展都是十分有用的东西。

```cpp
int prime[n + 100];
bool vis[n + 100];//用前需要初始化为false
void oula(int n) {
    int cnt = 0;
    for(int i = 2; i <= n; i++)
    {
        if(!vis[i])
            prime[++cnt] = i;
        for(int j = 1; j <= cnt && i*prime[j] <= n; j++)
        {
            vis[i*prime[j]] = true;
            if(i % prime[j] == 0) break;
        }
    }
}
```

### 6.1.1.2 分块求筛

> 分块求筛是欧拉筛的一种改进。
> 分块求筛的时间复杂度为$O$($n$)，空间复杂度为$O$($n$)。

```cpp
//分块求筛
int count_primes(int n) {
    const int S = 10000;
    vector<int> primes;
    int nsqrt = sqrt(n);
    vector<char> is_prime(nsqrt + 1, true);
    for (int i = 2; i <= nsqrt; i++) 
    {
        if (is_prime[i]) {
            primes.push_back(i);
        for (int j = i * i; j <= nsqrt; j += i) 
            is_prime[j] = false;
        }
    }
    int result = 0;
    vector<char> block(S);
    for (int k = 0; k * S <= n; k++) 
    {
        fill(block.begin(), block.end(), true);
        int start = k * S;
        for (int p : primes) 
        {
            int start_idx = (start + p - 1) / p;
            int j = max(start_idx, p) * p - start;
            for (; j < S; j += p) 
            block[j] = false;
        }
        if (k == 0) 
            block[0] = block[1] = false;
        for (int i = 0; i < S && start + i <= n; i++) 
        {
            if (block[i]) result++;
        }
    }
    return result;
}
```

### 6.1.1.3 杜教筛

>只有一个重要的公式
>$g(1)S(n) = \sum_{i=1}^{n}(f*g)(i)-\sum_{i=2}^{n}g(i)S(\lfloor \frac {n} {i} \rfloor)$
>常用迪利克雷卷积
>$\mu*I=\epsilon$
>$\varphi*I=id$
>$\mu*id=\varphi$

### 6.1.1.4 洲阁筛

## 6.1.2 因数分解

> 因数分解是一个非常有用的东西。
> 但无特别简单的算法可以快速的求出因数分解。
> 一种优化是枚举质数到n^1/2，时间复杂度为$O$($n^1/2$),实现较为简便。

```cpp
//因数分解
void factor(int n) {
    int tmp = sqrt(n);
    for(int i = 2; i <= tmp; i++)
    {
        if(n % i == 0)
        {
            printf("%d ", i);
            factor(n / i);
            n /= i;
            i--;
        }
    }
}
```

## 6.2. 数论算法

### 6.2.1. 中国剩余定理

> 中国剩余定理又名孙子定理。
> 主要用来求解一元线性同余方程组

```cpp
//中国剩余定理
int chinese_remainder(int n, int a[], int m[]) {
    int result = 0;
    int M = 1;
    for(int i = 0; i < n; i++)
    {
        M *= m[i];
    }
    for(int i = 0; i < n; i++)
    {
        int x = M / m[i];
        int y = a[i] * x % M;
        result = (result + y) % M;
    }
    return result;
}
```

## 6.2.2 同余方程

### 6.2.2. 裴蜀定理

> decription:
> 



