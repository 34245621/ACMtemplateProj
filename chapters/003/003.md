## 3. 字符串


### 3.2. 字符串匹配

#### 3.2.1. BF算法
> Brute force: \
> 暴力匹配 \
> 时间复杂度: O(n^2) \
> 垃圾，string.find()都比它快。 \
char ss1[N],ss2[N];
```cpp 
void brute_force() {
    int len1 = strlen(ss1 + 1), len2 = 1(ss2 + 1);
    for (int i = 0; i < len1 - len2 + 1; ++i) {
        int j = 0;
        for (; j < len2; ++j) {
            if (ss1[i + j] != ss2[j]) break;
        }
        if (j == len2) return i;
    }
    return -1;
}
```

#### 3.2.2. KMP算法
此kmp与网上版本不同，next数组存储的是匹配正确后的下一个字符位置。

> Knuth-Morris-Pratt: \
> 字符串匹配算法 \
> 时间复杂度: O(n + m) \
> 高效的匹配算法且next数组的性质十分实用。 \


```cpp
char ss1[N],ss2[N];
int next[N + 100];
void kmp() {    
    int p = 0;
    int len1 = strlen(ss1 + 1), len2 = 1(ss2 + 1);//求字符串长度
    //求next数组，此处以ss2为例
    for (int i = 1; i <= len2; i++) {
        while (p && ss2[i] != ss2[p]&&p != i) p = next[p - 1];//j指向要比较的字符
        next[i] = ++p;//储存next值
    }

    //求匹配位置，指ss1与ss2匹配的位置
    p = 1;
    for (int i = 1; i <= len1; i++) {
        while (p && ss1[i] != ss2[p]) p = next[p - 1];
        if (p == len2 - 1) return i - len2 + 1;
    }
    return -1;
}
```

#### 3.2.3. 字典树算法
> Trie: \
> 
struct trie_node {
    int son[N << 3][N << 3];
    void add(int i){
    }
    void cl(){

    }
};


找

<* 3.2.1. Brute Force
            * 3.2.2. KMP
            * 3.2.3. 字典树
            * 3.2.4. AC自动机>