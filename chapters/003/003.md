## 3. 字符串


### 3.2. 字符串匹配

#### 3.2.1. BF算法
> Brute force: \
> 暴力匹配 \
> 时间复杂度: O(n^2) \
> 垃圾，string.find()都比它快。 \
char ss1[N],ss2[N];
```cpp 
void brute_force() {
    int len1 = strlen(ss1 + 1), len2 = 1(ss2 + 1);
    for (int i = 0; i < len1 - len2 + 1; ++i) {
        int j = 0;
        for (; j < len2; ++j) {
            if (ss1[i + j] != ss2[j]) break;
        }
        if (j == len2) return i;
    }
    return -1;
}
```

#### 3.2.2. KMP算法
此kmp与网上版本不同，next数组存储的是匹配正确后的下一个字符位置。

> Knuth-Morris-Pratt: \
> 字符串匹配算法 \
> 时间复杂度: O(n + m) \
> 高效的匹配算法且next数组的性质十分实用。 \


```cpp
char ss1[N],ss2[N];
void kmp() {
    int next[N + 100];
    int j = 0;
    int len1 = strlen(ss1 + 1), len2 = 1(ss2 + 1);//求字符串长度
    //求next数组，此处以ss2为例
    for (int i = 1; i <= len2; i++) {
        while (j && ss2[i] != ss2[j]) j = next[j - 1] - 1;//j指向要比较的字符
        next[i] = ++j;
    }

    j = -1;
    for (int i = 1; i <= len1; i++) {
        while (j >= 0 && ss1[i] != ss2[j + 1]) j = next[j];
        if (ss1[i] == ss2[j + 1]) ++j;
        if (j == len2 - 1) return i - len2 + 1;
    }
    return -1;
}
```

#### 3.2.3. 字典树算法
> Trie: \
> 
struct trie_node {
    int son[N << 3][N << 3];
    void add(int i){
    }
    void cl(){

    }
};


找

<* 3.2.1. Brute Force
            * 3.2.2. KMP
            * 3.2.3. 字典树
            * 3.2.4. AC自动机>